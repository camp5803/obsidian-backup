
## B-Tree

`B-Tree`는 정렬을 유지한 `Tree` 자료구조의 일종으로, `Binary Search Tree`의 확장 개념이라고 볼 수도 있다. 다만 `Binary Tree`의 구조와 다르게 자식 노드의 최대 개수가 2보다 크다는 점이 `B-Tree`의 핵심 구조이다.

![](../image/b-tree1.png)

`BST`는 부모 노드를 기준으로 양쪽에 특정한 기준으로 정렬을 했는데, 그렇다면 `B-Tree`는 어떻게 정렬을 해야 할까? `B-Tree`도 마찬가지로 한 방향으로 정렬되어야 하는데 이 부분에서 이해하기 어렵다.

![](../image/b-tree2.png)

위와 같이 부모 노드에 두 개의 값을 넣으면 정렬을 유지하면서도 자식 노드의 수가 2보다 크게 할 수 있다. 

즉 `B-Tree`의 핵심은 모든 부모 노드는 오름차순으로 정렬된 하나 이상의 `key`를 가지며, 부모 노드의 `key`에 따라서 자녀 노드들의 `key`의 개수 범위가 정해진다는 것이다. 

즉, 부모 노드의 `key`의 개수가 `M - 1`개라고 한다면 자식 노드의 수는 최대 `M`개가 된다. 또한 자식 노드들은 순차적으로 정렬된 부모 노드의 `key`값들에 의해 범위가 정해진다.

예를 들어, 부모 노드의 `key`값이 `[3, 5, 7]`인 경우에는 모든 자식 노드가 채워져 있다고 할 때, 자식 노드들의 범위는 각각 `R < 3, 3 < R < 5, 5 < R < 7, R > 7`이 된다.

	B-Tree의 최대 자녀 수가 M일 때, 그 B-Tree는 M차 B-Tree라고 부른다.
	이 때, B-Tree는 몇 개의 파라미터를 가진다.
	
	- M: 각 노드의 최대 자녀 노드의 수
	- M-1: 각 노드의 최대 key의 수
	- ⌈ M/2 ⌉: 각 노드의 최소 자녀 노드의 수 *루트 노드, 리프 노드 제외
	- ⌈ M/2 ⌉-1: 각 노드의 최소 key의 수 *루트 노드 제외

### B-Tree의 데이터 삽입

	B-Tree에서 데이터 삽입 시 추가는 항상 리프 노드에 한다.
	만약 데이터 삽입 중 노드가 넘치면 가운데 key를 기준으로 좌우 key를 분할하고 가운데 key는 승진한다.

**[B-Tree 데이터 삽입 과정](../etc/btree.pptx)**

삽입 과정에서 알 수 있는 사실은, `B-Tree`의 모든 리프 노드는 같은 레벨에 있을 수 밖에 없다.

또한, 삽입 진행 시 데이터 조회를 진행하게 되는데 이 경우 트리의 높이만큼만 연산을 진행하기 때문에 최악의 경우에도 `O(logN)`의 시간 복잡도를 보인다. 다만 삽입 시에는 새로운 데이터를 리프 노드에 추가하게 되는데, 루트 노드부터 시작하여 리프 노드까지 데이터의 위치를 찾기 때문에 평균적인 경우에도 정확하게 시간 복잡도가 `O(logN)`이 된다.

### B-Tree의 데이터 삭제

	B-Tree의 데이터 삭제도 마찬가지르 리프 노드에서 이루어진다.

삽입 시와 마찬가지로 데이터 조회를 먼저 진행하게 된다. 이후 원하는 데이터의 위치를 찾고 삭제를 진행하게 되는데 이 때 문제가 발생할 수 있다. 

삭제 이후 데이터가 위치한 노드가 최소 `key`의 수를 만족한다면 다행이지만, 그렇지 않은 경우가 발생할 수 있다. 그 경우에는 `B-Tree`의 재조정이 필요하고 그 재조정 방식을 설명하도록 한다.

#### 데이터 삭제 후 문제 발생 시 해결 방법 (1)

	1. key 수가 여유있는 형제의 지원을 받는다. (형제는 같은 부모를 둔 리프 노드를 말함)
	1.1. 동생(왼쪽 형제)이 여유가 있는 경우
	    -> 동생의 가장 큰 key를 부모 노드에서 나와 동생 사이에 위치하는 곳에 둔다.
	    -> 원래 그 자리에 있던 key는 나의 가장 왼쪽에 둔다
	1.2. 동생이 여유가 없고, 형(오른쪽 형제)이 여유가 있는 경우
	    -> 형의 가장 작은 key를 부모 노드에서 나와 형 사이에 위치하는 곳에 둔다.
	    -> 원래 그 자리에 있던 key는 나의 가장 오른쪽에 둔다.

위와 같은 방식으로 최소 `key`의 수를 만족시키기 위해 우선 형제의 도움을 받는 방법이 있다. 만약 형제의 도움을 받을 수 없는 경우에는 다음과 같은 방법으로 해결한다.

#### 데이터 삭제 후 문제 발생 시 해결 방법 (2)

	2. 형제의 지원이 불가능하면 부모의 지원을 받고 형제와 병합한다.
	2.1. 동생이 있는 경우
	    -> 부모 노드에서 나와 동생 사이에 위치하는 key를 받는다.
	    -> 그 key와 나의 key를 순서대로 동생에게 모두 옮긴다. (병합 과정)
	    -> 나의 노드를 삭제한다
	2.2. 동생이 없는 경우
	    -> 부모 노드에서 나와 형 사이에 위치하는 key를 받는다.
	    -> 그 key와 형의 key를 순서대로 나에게 옮긴다. (병합 과정)
	    -> 형의 노드를 삭제한다.

형제가 여유가 없는 경우에는 부모의 도움을 받아 형제와 같은 노드에서 살게 된다. 하지만 부모가 여유가 없는 경우도 존재하는데, 일단 지원을 받고 문제가 생긴 부모 노드를 해결해야 한다.

#### 데이터 삭제 후 문제 발생 시 해결 방법 (3)

	3. 부모의 문제를 해결하기 위해 부모도 위와 같은 과정을 밟아야 한다.
	3.1. 부모가 루트 노드가 아닌 경우
	    -> 그 위치에서부터 1번부터 재조정을 시작한다. (자신의 형제, 부모에게 지원을 받는 방식)
	3.2. 부모가 루트 노드이며 비어있는 경우
	    -> 부모 노드를 삭제한다.
	    -> 직전에 합쳐진 노드를 루트 노드로 한다.

여기서 바뀐 루트 노드의 경우에는 최소 `key`의 조건을 충족하지 못 할 수도 있다. 다만 위에서 봤던 파라미터에서 최소 `key`의 수는 부모 노드의 경우에는 예외기 때문에 넘어간다.

그런데 또 다른 문제가 있다. 만약 내가 지우고자 하는 값이 리프 노드가 아니라 내부 노드에 있다면 어떻게 할까? 

#### 내부 노드에서 삭제하는 경우

위에서 삭제는 항상 리프 노드에서 이루어져야 한다고 했다. 그렇다면 내가 삭제하고자 하는 데이터의 위치를 리프 노드로 변경하면 된다. 그런데 리프 노드는 여러 개가 있고 여기서 어떤 노드로 정해야 하는 지에 대한 기준이 필요하다.

이 경우 부모의 선임자나 후임자에게 도움을 받는다. 

	선임자(predecessor): 본인보다 작은 데이터들 중 가장 큰 데이터
	후임자(successor): 본인보다 큰 데이터들 중 가장 작은 데이터

이 두 개 중 상황에 맞게 선택하여 내부 노드의 `key`와 변경한 후 리프 노드를 제거하여 재조정 과정을 거치면 데이터 삭제는 끝난다.


### B+Tree

`B+Tree`는 기존의 `B-Tree`에서 조금 더 효율성을 추구하는 자료구조다. 

우선 데이터를 저장하는 위치를 보면 `B-Tree`에서는 내부 노드와 리프 노드 모두에 키 값을 저장한다. 주로 쓰는 데이터를 `Tree`의 상단에 위치시켜 효율적으로 `Access`를 하고자 한다. 

하지만 `B+Tree`는 리프 노드에만 실제 레코드를 저장하고 내부 노드에는 반드시 `key`만 저장한다. 그리고 리프 노드에 저장된 레코드들은 `Double Linked List`로 연결되어 순차적인 `Access`에서 큰 효율을 보인다. 또한 데이터는 모두 리프 노드에 저장하며 `key`의 범위를 통하여 접근하기 떄문에 `key`값이 중복될 수 있다.

위와 같은 특성에서 성능 차이가 보일 수 있는 부분은 범위 검색이다. `B-Tree`의 경우에는 지정된 범위의 데이터들을 우선 찾고 기준을 세워 그 사이의 데이터에 접근해야 하는 반면에 `B+Tree`는 모든 데이터가 연결된 리프 노드에 있기 때문에 시작 범위의 레코드에 접근하여 범위의 끝까지 순차적으로 접근이 가능하여 이득을 본다.

이와 같이 `B+Tree`는 `B-Tree`에서 확장하여 **데이터의 접근**의 측면에서 조금 더 일반화를 한 자료구조로 볼 수 있고, 실제로 데이터베이스 등에서 `indexing`을 하기 위해 자주 사용된다.

### DB와 B-Tree

데이터베이스 엔진들은 `index`를 `B-Tree` 계열의 자료구조로 구현한다. 예를 들어보면 `MYSQL`의 `InnoDB`도 `B+Tree`를 이용해 구현되었다. 

왜 `B-Tree` 계열의 자료구조를 사용할까에 대한 정답은 성능에 있다. 데이터베이스는 `R/W`가 빈번하게 일어나기에 당연하게 성능이 가장 우선이다. 선형 구조인 `List` 계열의 데이터베이스는 사실 성능은 둘째로 치더라도 구조적으로 데이터를 저장해야 하는 특성과 어울리지 않으며, 성능 또한 적합하지 않다.

그렇다면 다른 `Tree` 계열의 자료구조는 왜 선택받지 못한걸까? 데이터를 정렬해서 저장한 `Binary Search Tree(이하 BTS)` 계열의 `AVL Tree`나 `Red-Black Tree` 또한 평균적인 경우와 최악의 경우에도 Read, Write, Delete에서 `O(logN)`의 시간 복잡도를 보이며 성능에서 크게 밀리지는 않는 것으로 보인다.

이 부분은 물리적인 저장장치와 함께 생각해보면 알 수 있는데, `SSD, HDD`와 같은 스토리지에서 `RAM`으로 데이터를 옮길 때엔 한 번에 하나의 데이터만을 가져오는 게 아닌 `block` 단위로 데이터를 가져오게 된다. 그렇다면 이런 데이터를 가져올 때 효율적으로 가져오기 위해서는 그 `block` 안에 연관된 데이터가 있도록 하면 스토리지의 `R/W`에서 성능적 이득을 볼 수 있다는 것이다.

그럼 기존의 `BST` 계열의 자료구조와 `B-Tree` 계열의 자료구조를 비교해보면, `BST` 계열의 자료구조는 하나의 노드에는 하나의 데이터만 저장이 가능하다. 반대로 `B-Tree`의 경우에는 하나의 노드에 `M-1`개의 데이터가 저장이 가능하다. 이런 방식으로 연관된 데이터(`B-Tree`에서 노드는 특정 범위의 데이터들을 가지고 있기 때문)를 가지고 있기 때문에 성능적 이득을 볼 수 있다는 것이다.

또한 기본적인 특징으로 범위를 나눠서 노드에 여러 개의 데이터를 가지고 있기 때문에 `Tree`의 높이도 다르다. `B-Tree` 계열의 자료구조는 같은 개수의 데이터를 저장할 때 차수가 높으면 높을수록 `BST` 계열의 트리보다 높이가 훨씬 낮기 때문에 실질적인 스토리지 접근이 적다는 것이다.

이렇게 같은 시간 복잡도를 가진다고 해서, 꼭 성능이 같은 것이 아니다. `O(logN)`으로 동일하더라도 데이터가 많으면 많을수록 차이가 크게 벌어지기에 더 많이 사용되는 것이다.

