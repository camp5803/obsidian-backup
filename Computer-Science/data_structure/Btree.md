
## B-Tree

`B-Tree`는 정렬을 유지한 `Tree` 자료구조의 일종으로, `Binary Search Tree`의 확장 개념이라고 볼 수도 있다. 다만 `Binary Tree`의 구조와 다르게 자식 노드의 최대 개수가 2보다 크다는 점이 `B-Tree`의 핵심 구조이다.

![](../image/b-tree1.png)

`BST`는 부모 노드를 기준으로 양쪽에 특정한 기준으로 정렬을 했는데, 그렇다면 `B-Tree`는 어떻게 정렬을 해야 할까? `B-Tree`도 마찬가지로 한 방향으로 정렬되어야 하는데 이 부분에서 이해하기 어렵다.

![](../image/b-tree2.png)

위와 같이 부모 노드에 두 개의 값을 넣으면 정렬을 유지하면서도 자식 노드의 수가 2보다 크게 할 수 있다. 

즉 `B-Tree`의 핵심은 모든 부모 노드는 오름차순으로 정렬된 하나 이상의 `key`를 가지며, 부모 노드의 `key`에 따라서 자녀 노드들의 `key`의 개수 범위가 정해진다는 것이다. 

즉, 부모 노드의 `key`의 개수가 `M - 1`개라고 한다면 자식 노드의 수는 최대 `M`개가 된다. 또한 자식 노드들은 순차적으로 정렬된 부모 노드의 `key`값들에 의해 범위가 정해진다.

예를 들어, 부모 노드의 `key`값이 `[3, 5, 7]`인 경우에는 모든 자식 노드가 채워져 있다고 할 때, 자식 노드들의 범위는 각각 `R < 3, 3 < R < 5, 5 < R < 7, R > 7`이 된다.

	B-Tree의 최대 자녀 수가 M일 때, 그 B-Tree는 M차 B-Tree라고 부른다.
	이 때, B-Tree는 몇 개의 파라미터를 가진다.
	
	- M: 각 노드의 최대 자녀 노드의 수
	- M-1: 각 노드의 최대 key의 수
	- ⌈ M/2 ⌉: 각 노드의 최소 자녀 노드의 수 *루트 노드, 리프 노드 제외
	- ⌈ M/2 ⌉-1: 각 노드의 최소 key의 수 *루트 노드 제외

### B-Tree의 데이터 삽입

	B-Tree에서 데이터 삽입 시 추가는 항상 리프 노드에 한다.
	만약 데이터 삽입 중 노드가 넘치면 가운데 key를 기준으로 좌우 key를 분할하고 가운데 key는 승진한다.

**[B-Tree 데이터 삽입 과정](../etc/btree.pptx)**

삽입 과정에서 알 수 있는 사실은, `B-Tree`의 모든 리프 노드는 같은 레벨에 있을 수 밖에 없다.

또한, 삽입 진행 시 데이터 조회를 진행하게 되는데 이 경우 트리의 높이만큼만 연산을 진행하기 때문에 최악의 경우에도 `O(log N)`의 시간 복잡도를 보인다.