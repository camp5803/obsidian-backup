
## Dynamic Programming

`Dynamic Programming(동적 계획법)`은 중복되는 부분 문제들의 해결책을 결합하여 전체 문제의 해결책은 찾는 최적화 기법이다. 특정 알고리즘으로 최적해를 구할 때 시공간적인 복잡도가 너무 커져서 연산 속도와 메모리 공간을 최대한으로 활용하고자 설계된 방법론이다.

	최적해를 구하는 알고리즘 중 DP와 크게 비교되는 것은 Brute Force나 Recursive 등이 있다. 

`DP`로 쉽게 최적해를 구할 수 있는 예시에는 피보나치 수열이 있다. 후에 설명하겠지만 `DP` 문제 풀이에 있어서는 항 간의 관계를 파악해서 점화식을 세워 풀이를 해야 하는데, 피보나치 수열이 이를 설명하기 적합하다.

```python
def fibo(x):
	if x == 0 or x == 1:
		return x
	return fibo(x - 1) + fibo(x - 2)
```

기존의 방법으로 재귀 함수를 이용하여 호출하는 방식이다. 

$$ a(n) = a(n-1) + a(n-2) \quad \text{for } n \geq 2 $$

주어지는 인자에 따라서 모든 하위 문제들을 조합하여 해를 구하는 방식이다. 다만 실제로 실행시켜보면 알겠지만 항의 수가 커짐에 따라 연산 시간이 기하급수적으로 올라간다. 실제로 사용하기에 크게 무리가 있는 구현 방식이라는 것을 알 수 있다. 

`DP`에서는 이런 문제를 쉽게 해결 할 수 있는데, 재귀 방식이 크게 느릴 수 밖에 없는 이유는 이미 계산한 모든 값을 다시 계산한다는 부분이다. `DP`는 이 문제를 해결하면서 메모리와 연산 속도에서 크게 이득을 볼 수 있다.

```python
d = [0] * (N + 1)

def fibo(x):
	if x == 0 or x == 1:
		return x
	if d[x] != 0:
		return d[x]
	d[x] = fibo(x - 1)  fibo(x - 2)
	return d[x]	
```

재귀 방식에선 `a(50)`을 구하는 것도 결과를 보기 어려울 만큼 연산 속도가 느렸지만, `DP`를 이용하면 순식간에 해를 도출해낸다.

다만 `DP`는 `Greedy Algorithm`과 마찬가지로 전제 조건이 있는데, **최적 부분 구조**와 **중복 부분 문제**를 만족해야 한다. 즉, 부분의 최적해를 통해 전체의 최적해를 도출해 낼 수 있어야 하며 작은 부분 문제들이 여러 번 반복되는 경우에 사용할 수 있다.

### Top-down (Memoization)

`DP`를 구현하는 방식은 크게 두 개가 있다. 
### Bottom-up (Tabulation)