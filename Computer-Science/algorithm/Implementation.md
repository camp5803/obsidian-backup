
## Implementation

알고리즘 문제 풀이에서 `Implementation(구현)`이라는 분야는 구현이 복잡한 분야를 말한다. 이 경우 문제 풀이를 하는 언어의 숙련도가 가장 중요하고, 정확한 풀이를 떠올리기 위한 시간을 가져야 한다.

`Implementation` 문제를 풀기 전에, 문제를 여러 번 읽고 정확하게 이해해야 한다. 문제의 난이도에 따라서 문제에서 설정한 조건, 예외 상황, 입출력 형태 등 다양한 방법으로 구현의 난이도를 정하기 때문에 정답을 찾기 위해서는 이 모든 상황을 이해해야만 한다. 특히, 시뮬레이션 문제의 경우엔 문제 자체를 이해하기 어려운 경우가 있으니 참고하면 좋다.

	 시뮬레이션은 문제에서 제시한 행위를 단계별로 수행해야 하는 문제 유형이다. 일반적으로 구현이 까다롭기 때문에 구현과 같이 있는 경우가 많다.

또한, 상황에 맞는 알고리즘을 활용할 줄 알면 크게 도움이 된다. 효율성과 정확성을 고려하여 빠르게 알고리즘을 선택하고 풀이하는 능력이 요구되는데, 이 경우 사용하는 언어의 라이브러리를 잘 활용할 수 있는 지가 중요하다. 

특정 자료구조를 이용하면 효율적으로 문제를 해결할 수 있는 경우도 있고, 특히 수학 계열의 문제인 경우 수학 관련 라이브러리를 이용해야만 효율적으로 풀이할 수 있다.

문제가 복잡한 경우에는 문제 풀이를 바로 시도하기보다 로직을 대략적으로 계획해서 풀면 도움이 될 수 있다.

### Implementation 예제

[프린터 큐 (Silver 3)](https://www.acmicpc.net/problem/1966)

**문제**

	여러분도 알다시피 여러분의 프린터 기기는 여러분이 인쇄하고자 하는 문서를 인쇄 명령을 받은 ‘순서대로’, 즉 먼저 요청된 것을 먼저 인쇄한다. 여러 개의 문서가 쌓인다면 Queue 자료구조에 쌓여서 FIFO - First In First Out - 에 따라 인쇄가 되게 된다. 하지만 상근이는 새로운 프린터기 내부 소프트웨어를 개발하였는데, 이 프린터기는 다음과 같은 조건에 따라 인쇄를 하게 된다.
	
	1. 현재 Queue의 가장 앞에 있는 문서의 ‘중요도’를 확인한다.
	2. 나머지 문서들 중 현재 문서보다 중요도가 높은 문서가 하나라도 있다면, 이 문서를 인쇄하지 않고 Queue의 가장 뒤에 재배치 한다. 그렇지 않다면 바로 인쇄를 한다.
	
	예를 들어 Queue에 4개의 문서(A B C D)가 있고, 중요도가 2 1 4 3 라면 C를 인쇄하고, 다음으로 D를 인쇄하고 A, B를 인쇄하게 된다.
	
	여러분이 할 일은, 현재 Queue에 있는 문서의 수와 중요도가 주어졌을 때, 어떤 한 문서가 몇 번째로 인쇄되는지 알아내는 것이다. 예를 들어 위의 예에서 C문서는 1번째로, A문서는 3번째로 인쇄되게 된다.

**입력**

	첫 줄에 테스트케이스의 수가 주어진다. 각 테스트케이스는 두 줄로 이루어져 있다.
	
	테스트케이스의 첫 번째 줄에는 문서의 개수 N(1 ≤ N ≤ 100)과, 몇 번째로 인쇄되었는지 궁금한 문서가 현재 Queue에서 몇 번째에 놓여 있는지를 나타내는 정수 M(0 ≤ M < N)이 주어진다. 이때 맨 왼쪽은 0번째라고 하자. 두 번째 줄에는 N개 문서의 중요도가 차례대로 주어진다. 중요도는 1 이상 9 이하의 정수이고, 중요도가 같은 문서가 여러 개 있을 수도 있다.

**출력**

	 각 테스트 케이스에 대해 문서가 몇 번째로 인쇄되는지 출력한다.

**예제 입력 1**

	3
	1 0
	5
	4 2
	1 2 3 4
	6 0
	1 1 9 1 1 1

**예제 출력 1**

	1
	2
	5

#### 예제 풀이

이 문제는 `Queue`에서 원소를 제거하고, 제거한 원소가 그 안에서 중요도가 가장 높은 원소가 아니면 삽입하기를 반복해야 한다. 즉, 내가 궁금한 원소의 위치가 계속 변할 수 있다는 점을 주목해야 한다. 

그렇다면 작성될 로직은 다음과 같다.

	 1. Queue에서 원소를 제거 할 때 가장 중요도가 큰지 검사
	 1.1. 맞다면 제거 순서를 카운트
	 1.1.1. 내가 궁금했던 원소었다면 반복문 탈출
	 1.2. 아닌 경우 다시 rear에 삽입
	 2. 원소가 제거되었건, 그렇지 않건 Queue는 한 번 땡겨졌으므로 궁금한 원소의 위치를 체크

```python
import sys  
from collections import deque  
  
T = int(sys.stdin.readline().rstrip())  
  
for _ in range(T):  
    N, M = map(int, sys.stdin.readline().split())  
    queue = deque(list(map(int, sys.stdin.readline().split())))  
    count = 0  
  
    while queue:  
        important = max(queue)  
        top = queue.popleft()  
  
        if top == important:  
            count += 1  
            if M == 0:  
                break  
        else:  
            queue.append(top)  
  
        M -= 1  
        if M < 0:  
            M = len(queue) - 1  
  
    print(count)
```

문제 자체는 기초적인 자료구조를 이용한 문제로, 난이도 자체는 어렵지 않으나 여러 조건을 충족해야 하므로 꼼꼼히 문제를 읽고 생각을 정리하는 능력이 요구된다.

### 풀어보면 좋은 예제

[톱니바퀴 (Gold 5)](https://www.acmicpc.net/problem/14891)